attribute vec3 v_position;
attribute vec2 v_uv;
attribute vec3 v_normal;

varying vec2 uv;

varying vec3 v_position_world;
varying vec3 v_position_camera;
varying vec3 v_normal_camera;
varying vec3 l_position_world;
varying vec3 l_position_camera;

uniform vec4 l_lightpos;
uniform vec4 l_diffuse;
uniform mat4 mvpMatrix;
uniform mat4 vMatrix;
uniform mat4 mMatrix;

void main(void){
	float attenuation = 1.0;
	/*
	vec3 normalDirection = normalize( v_normal );
	vec3 lightDirection = normalize( vec3(l_lightpos) );
	*/

	//get the position in world space and camera space
	v_position_world = vec3( mMatrix * vec4(v_position, 1.0) );
	v_position_camera = vec3( vMatrix * mMatrix * vec4(v_position, 1.0) );
	v_normal_camera = vec3( vMatrix * mMatrix * vec4(v_normal, 1.0) );
	l_position_world = vec3(l_lightpos);
	l_position_camera = vec3( vMatrix * l_lightpos );


	//vector that goes from the vertex to the camera (camera space)
	vec3 vertToCam = v_position_camera - vec3(0.0, 0.0, 0.0);

	//vector that goes from the vertex to the light (camera space)
	vec3 vertToLight = l_position_camera + vertToCam;

	//declare variables for actual math
	float distance = length( vec3(l_lightpos) - v_position_world );
	vec3 normal = normalize( v_normal_camera );
	vec3 light = normalize( l_position_camera );
	vec3 eye = normalize( vertToCam );
	vec3 reflect = reflect( -light, normal );

//	float cosTheta = max(0.0, dot(normal, light));
	float cosTheta = max( 0.0, dot(-(vec3(l_lightpos) - v_position_world), vec3(l_lightpos)));
	float cosAlpha = clamp( dot( eye, reflect ), 0, 1 );

//	vec3 finalColor = attenuation * (( cosTheta / distance * distance ) + (pow(cosAlpha, 5) / distance * distance)) * vec3(l_diffuse);
	if( cosTheta < 30.0/180.0*3.14159265 ){
		attenuation = 0.0;
	} else {
		attenuation = pow( cosTheta, 0.2 );
	}

	vec3 finalColorIntensity = attenuation * vec3(l_diffuse	) * max(0.0, dot(normal, light));
	if( l_diffuse[3] == 0.0f ){
		attenuation == 1.0;
	}
	else if ( l_diffuse[3] == 1.0 ){
		attenuation = 1.0;
	}
	else if ( l_diffuse[3] == 2.0 ){

		float clampedCosine = max( 0.0, dot(light, normal) );
		if( clampedCosine < 30.0/180.0*3.14159265 ){
			attenuation = 0.0;
		} else {
			attenuation = pow( clampedCosine, 0.2 );
		}
	}
/*
*/


	//position of the vertex (clip space)
	gl_Position = mvpMatrix * vec4(v_position, 1.0);
	uv = v_uv;
}